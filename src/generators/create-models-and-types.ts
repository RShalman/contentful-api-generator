import fs from "fs";
import prettier from "prettier";
import { capitalize } from "../utils/commons.js";
import { findById } from "./create-entries.js";

const basePath = "/api/contentful";
const exportFilePath = `${basePath}/data/contentful-export.json`;
const typesModelPath = `${basePath}/contentTypes.json`;
const localesModelPath = `${basePath}/locales.json`;
const localesTSPath = `${basePath}/locales.ts`;
const typesTSPath = `${basePath}/contentTypes.ts`;

const onError = (err) => {
  throw new Error(`Seems like file is empty or doesnt exist: ${err}`);
};

function typeAdapter(fieldName, type, field) {
  const arrOfItems = field.arrayTypeItems
    ? field?.arrayTypeItems?.reduce(
        (acc, cur, i, arr) =>
          acc +
          (cur === "string"
            ? cur
            : `CContentTypes<L>['${cur}']${
                i !== arr.length - 1 ? " | " : ""
              }\n`),
        ""
      )
    : false;

  const arrOfValidationTypes = field.validationTypes
    ? field?.validationTypes?.reduce(
        (acc, cur, i, arr) =>
          acc +
          (cur === "string"
            ? cur
            : `CContentTypes<L>['${cur}']${
                i !== arr.length - 1 ? " | " : ""
              }\n`),
        ""
      )
    : false;

  return (
    {
      Array: arrOfItems ? `Array<${arrOfItems}>` : type,
      Link:
        field.linkType === "Entry"
          ? arrOfValidationTypes || `CT${capitalize(fieldName)}<L>`
          : `${field.linkType}<L>`,
      Integer: "number",
    }[type] ?? type
  );
}

function typeTemplate(name, fields) {
  return `
      export type CT${name.split(" ").join("")}<L extends CTLocales> = {
        ${Object.keys(fields).reduce((typeAcc, typeCur) => {
          const field = fields[typeCur];

          const withAsset =
            field.linkType === "Asset"
              ? typeAdapter(typeCur, field.type, field)
              : `Record<L, ${typeAdapter(typeCur, field.type, field)}>`;

          return (
            typeAcc + `${typeCur}${field.required ? "" : "?"}: ${withAsset};`
          );
        }, "")}
          }

          \n
          `;
}

function typesReferenceType(typesModel) {
  return `
      export type CContentTypesKeys = keyof CContentTypes<CTLocales>\n
      export type CContentTypes<L extends CTLocales> = {${typesModel.reduce(
        (acc, cur) =>
          acc + `${cur.contentTypeId}: CT${cur.name.split(" ").join("")}<L>;`,
        ``
      )}}
      
      \n
    `;
}

export function createTypesModels() {
  const contentfulExportFile = JSON.parse(
    fs.readFileSync(__dirname + exportFilePath).toString()
  );
  const { contentTypes, locales } = contentfulExportFile ?? {};

  if (locales) {
    const procLocales = locales.map(({ name, code }) => ({ name, code }));
    const localesToTS = `export type CTLocales = ${procLocales.reduce(
      (acc, cur, idx) =>
        acc + (idx === 0 ? `'${cur.code}'` : ` | '${cur.code}'`),
      ""
    )}`;

    fs.writeFileSync(
      __dirname + localesModelPath,
      JSON.stringify(procLocales, null, 2)
    );
    fs.writeFileSync(__dirname + localesTSPath, localesToTS);
  } else {
    onError("No locales provided");
  }

  if (contentTypes) {
    const procContentTypes = contentTypes.map(({ sys, name, fields }) => ({
      contentTypeId: sys.id,
      name,
      fields: fields
        .filter((f) => !f.disabled)
        .reduce((acc, { id, type, linkType, required, items, validations }) => {
          return {
            ...acc,
            [id]: {
              type: type === "Symbol" ? "string" : type,
              required,
              linkType,
              validationTypes:
                findById(contentTypes, id) !== null
                  ? false
                  : validations?.[0]?.linkContentType,
              arrayTypeItems: (type === "Array" &&
                items.validations?.[0]?.linkContentType) ?? [
                items?.type === "Symbol" ? "string" : items?.type,
              ],
            },
          };
        }, {}),
    }));

    fs.writeFileSync(
      __dirname + typesModelPath,
      JSON.stringify(procContentTypes, null, 2)
    );
  } else {
    onError("No content types provided");
  }
}

export function createTypesTS() {
  const typesModel = JSON.parse(
    fs.readFileSync(__dirname + typesModelPath).toString()
  );

  if (typesModel) {
    const notification = `// WARNING! Bear in mind this file is automatically generated.\n // DO NOT make any changes manually\n\n`;
    const imports = `import { EntryFields, Sys } from 'contentful';
                     import RichText = EntryFields.RichText;
                     import Link = EntryFields.Link;
                     import { CTLocales } from '@api/contentful/locales';
                     \n`;

    const entryType = `
          export type CTEntryOfTypes<E> = CTEntry<E, CContentTypes<CTLocales>[CContentTypesKeys]>;
          export type CTEntry<E, F> = Omit<E, 'fields'> & { metadata: Record<string, unknown>, fields: F, sys: Sys };\n
    `;

    const assetType = `
      export type Asset<L extends CTLocales> =  {
        title: Record<L, string>
        description: Record<L, string>
        file: Record<L, {
          url: string,
          details: {
            size: number,
            image: {
              width: number,
              height: number
            }
          },
          fileName: string,
          contentType: string
        }>
      }
    `;

    const contentTypes = `${typesModel.reduce((acc, typeObj) => {
      const { name, fields } = typeObj;

      const type = typeTemplate(name, fields);
      return acc + type;
    }, "")}`;

    const filepath = __dirname + typesTSPath;
    const validContent = prettier.format(
      notification +
        imports +
        assetType +
        entryType +
        typesReferenceType(typesModel) +
        contentTypes,
      { filepath }
    );
    fs.writeFileSync(filepath, validContent);
  } else {
    onError("No model types provided");
  }
}
